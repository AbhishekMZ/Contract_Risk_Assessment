import re
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class Severity(str, Enum):
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class Vulnerability:
    type: str
    severity: Severity
    description: str
    line: int
    pattern: Optional[str] = None
    recommendation: Optional[str] = None

class VulnerabilityDetector:
    def __init__(self):
        self.patterns = [
            # Reentrancy patterns
            {
                "type": "reentrancy",
                "severity": Severity.HIGH,
                "patterns": [
                    r'\.call\.value\s*\([^)]*\)\s*\(',  # .call.value()
                    r'\.send\s*\([^)]*\)(?!.*\.gas\s*\()',  # .send() without gas stipend
                ],
                "description": "Potential reentrancy vulnerability. State changes should be done before external calls.",
                "recommendation": "Use the checks-effects-interactions pattern and consider using transfer() or send() with a gas stipend."
            },
            # Integer overflow/underflow patterns
            {
                "type": "integer_overflow",
                "severity": Severity.HIGH,
                "patterns": [
                    r'(\w+)\s*[+\-*/%]\s*=',  # +=, -=, *=, /=, %=
                    r'(\w+)\s*[+\-*/%]\s*\w+',  # a + b, a - b, etc.
                ],
                "description": "Potential integer overflow/underflow. Arithmetic operations are not checked for overflows.",
                "recommendation": "Use SafeMath for arithmetic operations or Solidity 0.8+ which has built-in overflow checks."
            },
            # Unchecked external calls
            {
                "type": "unchecked_external_call",
                "severity": Severity.MEDIUM,
                "patterns": [
                    r'\.(call|send|transfer)\s*\([^)]*\)\s*;',  # Unchecked call/send/transfer
                ],
                "description": "Return value of low-level call not checked.",
                "recommendation": "Check the return value of low-level calls or use transfer() which reverts on failure."
            },
            # Unprotected function
            {
                "type": "unprotected_function",
                "severity": Severity.HIGH,
                "patterns": [
                    r'function\s+(?!internal|private)(\w+)\s*\('  # Public/external functions without modifiers
                ],
                "description": "Function can be called by anyone. Sensitive functions should be protected.",
                "recommendation": "Add access control modifiers like onlyOwner or require statements to restrict access."
            },
            # Bad randomness
            {
                "type": "bad_randomness",
                "severity": Severity.MEDIUM,
                "patterns": [
                    r'block\.(timestamp|number|hash\s*\()',  # Block properties for randomness
                    r'now'  # Alias for block.timestamp
                ],
                "description": "Using block.timestamp or blockhash for randomness is insecure.",
                "recommendation": "Use a commit-reveal scheme or an oracle for secure randomness."
            },
            # Uninitialized storage pointer
            {
                "type": "uninitialized_storage",
                "severity": Severity.HIGH,
                "patterns": [
                    r'\b(?:mapping|struct|array)\s+\w+\s+\w+\s*;'  # Uninitialized storage variables
                ],
                "description": "Potential uninitialized storage pointer.",
                "recommendation": "Explicitly initialize storage variables or use memory keyword for temporary variables."
            },
            # Denial of Service
            {
                "type": "denial_of_service",
                "severity": Severity.MEDIUM,
                "patterns": [
                    r'for\s*\([^;]*;\s*[^<>=!]*(<|>|<=|>=|==|!=)\s*[^;]*;',  # Bounded loops
                    r'while\s*\('  # While loops
                ],
                "description": "Potential unbounded loop that could cause DoS by consuming all gas.",
                "recommendation": "Avoid unbounded loops or implement a mechanism to limit the number of iterations."
            }
        ]

    def detect_vulnerabilities(self, source_code: str) -> List[Dict[str, Any]]:
        """
        Detect vulnerabilities in Solidity source code.
        
        Args:
            source_code: The Solidity source code to analyze
            
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        # Split source code into lines for line numbers
        lines = source_code.split('\n')
        
        for pattern_info in self.patterns:
            vuln_type = pattern_info["type"]
            severity = pattern_info["severity"]
            
            for pattern in pattern_info["patterns"]:
                # Compile the pattern for better performance
                compiled_pattern = re.compile(pattern)
                
                # Check each line for the pattern
                for line_num, line in enumerate(lines, 1):
                    if compiled_pattern.search(line):
                        # Skip comments and strings
                        if '//' in line or '/*' in line or '*/' in line or "'" in line or '"' in line:
                            continue
                            
                        vulnerabilities.append({
                            "type": vuln_type,
                            "severity": severity.value,
                            "description": pattern_info["description"],
                            "line": line_num,
                            "code_snippet": line.strip(),
                            "recommendation": pattern_info.get("recommendation", "")
                        })
                        
        return vulnerabilities

    def analyze_contract(self, source_code: str) -> Dict[str, Any]:
        """
        Analyze a Solidity contract for vulnerabilities.
        
        Args:
            source_code: The Solidity source code to analyze
            
        Returns:
            Dictionary containing analysis results
        """
        vulnerabilities = self.detect_vulnerabilities(source_code)
        
        # Count vulnerabilities by severity
        severity_counts = {
            Severity.HIGH.value: 0,
            Severity.MEDIUM.value: 0,
            Severity.LOW.value: 0,
            Severity.INFO.value: 0,
        }
        
        for vuln in vulnerabilities:
            severity = vuln["severity"]
            # Convert severity enum to string key
            severity_str = severity.value if isinstance(severity, Severity) else severity
            if severity_str in severity_counts:
                severity_counts[severity_str] += 1
            else:
                print(f"Warning: Unknown severity: {severity}")
        
        return {
            "vulnerabilities": vulnerabilities,
            "stats": {
                "total": len(vulnerabilities),
                "high": severity_counts[Severity.HIGH.value],
                "medium": severity_counts[Severity.MEDIUM.value],
                "low": severity_counts[Severity.LOW.value],
                "info": severity_counts[Severity.INFO.value],
            },
            "success": True
        }
